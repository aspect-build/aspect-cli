/*
 * Copyright 2022 Aspect Build Systems, Inc.
 *
 * Licensed under the aspect.build Commercial License (the "License");
 * you may not use this file except in compliance with the License.
 * Full License text is in the LICENSE file included in the root of this repository.
 */

// The outputs plugin adds a command to Aspect: "outputs".
// This is a simple wrapper around `bazel aquery` to discover the pre-declared output paths in the bazel-out
// tree which may be created by actions that a given target runs.
// This makes it easier to write scripts which reference Bazel outputs by predicting the path ahead-of-time,
// especially when transitions may cause the output to be written to a different output tree than expected.

package main

import (
	"context"
	"fmt"
	"strings"

	goplugin "github.com/hashicorp/go-plugin"

	"aspect.build/cli/pkg/bazel"
	"aspect.build/cli/pkg/plugin/sdk/v1alpha3/config"
	aspectplugin "aspect.build/cli/pkg/plugin/sdk/v1alpha3/plugin"
)

func main() {
	goplugin.Serve(config.NewConfigFor(New()))
}

type Outputs struct {
	aspectplugin.Base
}

func New() *Outputs {
	return &Outputs{}
}

func (plugin *Outputs) CustomCommands() ([]*aspectplugin.Command, error) {
	return []*aspectplugin.Command{
		aspectplugin.NewCommand(
			"outputs",
			"Inspect declared outputs.",
			"Queries for the outputs declared by actions generated by the given target.",
			plugin.NewOutputsCommand(),
		),
	}, nil
}

func (plugin *Outputs) NewOutputsCommand() aspectplugin.CustomCommandFn {
	return func(ctx context.Context, args []string, bzl bazel.Bazel) error {
		if len(args) < 1 {
			return fmt.Errorf("a label is required as the first argument to aspect outputs")
		}
		query := args[0]
		var mnemonicFilter string
		if len(args) > 1 {
			mnemonicFilter = args[1]
		}
		agc, err := bzl.AQuery(query)
		if err != nil {
			return err
		}

		// Use RAM to store lookup maps for these identifiers
		// rather than an O(n^2) algorithm of searching on each access.
		frags := make(map[uint32]*bazel.PathFragment)
		for _, f := range agc.PathFragments {
			frags[f.Id] = f
		}
		arts := make(map[uint32]*bazel.Artifact)
		for _, a := range agc.Artifacts {
			arts[a.Id] = a
		}

		// The paths in the proto data are organized as a trie
		// to make the representation more compact.
		// https://en.wikipedia.org/wiki/Trie
		// Make a map to store each prefix so we can memoize common paths
		prefixes := make(map[uint32]*[]string)

		// Declare a recursive function to walk up the trie to the root.
		var prefix func(pathID uint32) []string

		prefix = func(pathID uint32) []string {
			if prefixes[pathID] != nil {
				return *prefixes[pathID]
			}
			fragment := frags[pathID]
			// Reconstruct the path from the parent pointers.
			segments := []string{fragment.Label}

			if fragment.ParentId > 0 {
				segments = append(segments, prefix(fragment.ParentId)...)
			}
			prefixes[pathID] = &segments
			return segments
		}

		for _, a := range agc.Actions {
			if len(mnemonicFilter) > 0 && a.Mnemonic != mnemonicFilter {
				continue
			}
			for _, i := range a.OutputIds {
				artifact := arts[i]
				segments := prefix(artifact.PathFragmentId)
				var path strings.Builder
				// Assemble in reverse order.
				for i := len(segments) - 1; i >= 0; i-- {
					path.WriteString(segments[i])
					if i > 0 {
						path.WriteString("/")
					}
				}
				if len(mnemonicFilter) > 0 {
					fmt.Printf("%s\n", path.String())
				} else {
					fmt.Printf("%s %s\n", a.Mnemonic, path.String())
				}
			}
		}
		return nil
	}
}
