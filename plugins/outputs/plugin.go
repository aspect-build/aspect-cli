/*
 * Copyright 2022 Aspect Build Systems, Inc.
 *
 * Licensed under the aspect.build Commercial License (the "License");
 * you may not use this file except in compliance with the License.
 * Full License text is in the LICENSE file included in the root of this repository.
 */

package main

import (
	"context"
	"fmt"
	"strings"

	goplugin "github.com/hashicorp/go-plugin"

	"aspect.build/cli/pkg/bazel"
	"aspect.build/cli/pkg/plugin/sdk/v1alpha2/config"
	aspectplugin "aspect.build/cli/pkg/plugin/sdk/v1alpha2/plugin"
)

func main() {
	goplugin.Serve(config.NewConfigFor(New()))
}

type Outputs struct {
	aspectplugin.Base
}

func New() *Outputs {
	return &Outputs{}
}

func (plugin *Outputs) CustomCommands() ([]*aspectplugin.Command, error) {
	return []*aspectplugin.Command{
		aspectplugin.NewCommand(
			"outputs",
			"Inspect declared outputs.",
			"Queries for the outputs declared by actions generated by the given target.",
			func(ctx context.Context, args []string, bzl bazel.Bazel) error {
				if len(args) < 1 {
					return fmt.Errorf("A label is required as the first argument to aspect outputs")
				}
				query := args[0]
				var mnemonicFilter string
				if len(args) > 1 {
					mnemonicFilter = args[1]
				} else {
					mnemonicFilter = ""
				}
				agc, err := bzl.AQuery(query)
				if err != nil {
					return err
				}

				// Use RAM to store lookup maps for these identifiers
				// rather than an O(n^2) algorithm of searching on each access
				frags := make(map[uint32]*bazel.PathFragment)
				for _, f := range agc.PathFragments {
					frags[f.Id] = f
				}
				arts := make(map[uint32]*bazel.Artifact)
				for _, a := range agc.Artifacts {
					arts[a.Id] = a
				}

				// The paths in the proto data are organized as a trie
				// to make the representation more compact
				// https://en.wikipedia.org/wiki/Trie
				// Make a map to store each prefix so we can memoize common paths
				prefixes := make(map[uint32]*[]string)

				// Declare a recursive function to walk up the trie to the root
				var prefix func(pathID uint32) []string

				prefix = func(pathID uint32) []string {
					if prefixes[pathID] != nil {
						return *prefixes[pathID]
					}
					fragment := frags[pathID]
					// Reconstruct the path from the parent pointers.
					segments := []string{fragment.Label}

					if fragment.ParentId > 0 {
						segments = append(segments, prefix(fragment.ParentId)...)
					}
					prefixes[pathID] = &segments
					return segments
				}

				for _, a := range agc.Actions {
					if len(mnemonicFilter) > 0 && a.Mnemonic != mnemonicFilter {
						continue
					}
					for _, i := range a.OutputIds {
						artifact := arts[i]
						segments := prefix(artifact.PathFragmentId)
						var path strings.Builder
						// Assemble in reverse order.
						for i := len(segments) - 1; i >= 0; i-- {
							path.WriteString(segments[i])
							if i > 0 {
								path.WriteString("/")
							}
						}
						if len(mnemonicFilter) > 0 {
							fmt.Printf("%s\n", path.String())
						} else {
							fmt.Printf("%s %s\n", a.Mnemonic, path.String())
						}
					}
				}
				return nil
			},
		),
	}, nil
}
