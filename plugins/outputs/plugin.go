/*
 * Copyright 2022 Aspect Build Systems, Inc.
 *
 * Licensed under the aspect.build Commercial License (the "License");
 * you may not use this file except in compliance with the License.
 * Full License text is in the LICENSE file included in the root of this repository.
 */

// The outputs plugin adds a command to Aspect: "outputs".
// This is a simple wrapper around `bazel aquery` to discover the pre-declared output paths in the bazel-out
// tree which may be created by actions that a given target runs.
// This makes it easier to write scripts which reference Bazel outputs by predicting the path ahead-of-time,
// especially when transitions may cause the output to be written to a different output tree than expected.

package main

import (
	"context"
	"fmt"

	goplugin "github.com/hashicorp/go-plugin"

	"aspect.build/cli/pkg/bazel"
	"aspect.build/cli/pkg/plugin/sdk/v1alpha3/config"
	aspectplugin "aspect.build/cli/pkg/plugin/sdk/v1alpha3/plugin"
)

func main() {
	goplugin.Serve(config.NewConfigFor(New()))
}

type Outputs struct {
	aspectplugin.Base
}

func New() *Outputs {
	return &Outputs{}
}

func (plugin *Outputs) CustomCommands() ([]*aspectplugin.Command, error) {
	return []*aspectplugin.Command{
		aspectplugin.NewCommand(
			"outputs",
			"Inspect declared outputs.",
			"Queries for the outputs declared by actions generated by the given target.",
			plugin.NewOutputsCommand(),
		),
	}, nil
}

func (plugin *Outputs) NewOutputsCommand() aspectplugin.CustomCommandFn {
	return func(ctx context.Context, args []string, bzl bazel.Bazel) error {
		if len(args) < 1 {
			return fmt.Errorf("a label is required as the first argument to aspect outputs")
		}
		query := args[0]
		var mnemonicFilter string
		if len(args) > 1 {
			mnemonicFilter = args[1]
		}
		agc, err := bzl.AQuery(query)
		if err != nil {
			return err
		}
		outs := bazel.ParseOutputs(agc)
		for _, a := range outs {
			if len(mnemonicFilter) > 0 {
				if a.Mnemonic == mnemonicFilter {
					fmt.Printf("%s\n", a.Path)
				}
			} else {
				fmt.Printf("%s %s\n", a.Mnemonic, a.Path)
			}
		}
		return nil
	}
}
