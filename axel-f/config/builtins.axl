"""Configures builtin tasks for Workflows"""

load("../tasks/migrate.axl", "migrate")

load("../lib/platform.axl",
    "read_platform_config",
    "read_host_config",
    "get_bazelrc_flags",
    "DEFAULT_PLATFORM_DIR"
)

load(
    "../lib/github.axl",
    "create_check_run",
    "update_check_run",
    "complete_check_run",
    "build_output",
    "build_annotation",
    "create_review",
    "build_suggestion",
)

def _format_build_state(build_state):
    md = """
# Build Summary
Total: {}
Failed targets: {}
State: {}

""".format(
        build_state["total"],
        len(build_state["failures"]),
        "failure" if len(build_state["failures"]) else "success"
    )
    for target, failure in build_state["failures"].items():
        md += "## {}\n\n```{}```\n".format(target, failure.message)
    return md


def on_build_event(ctx: TaskContext, build_state: dict, event):
    if not build_state:
        build_state["total"] = 0
        build_state["failures"] = {}
    if event.kind == "target_completed":
        build_state["total"] += 1
        if not event.payload.success:
            build_state["failures"][event.id.label] = event.payload.failure_detail
            annotations = [
                build_annotation(
                    path = "README.md",      # NOT "./README.md"
                    start_line = 6,          # target the deleted lines
                    end_line = 6,
                    message = "Unused variable 'foo'",
                    annotation_level = "warning",
                ),
            ]
            r = create_check_run(
                ctx,
                token = "",
                owner = "thesayyn",
                repo = "wasp",
                name = "Build 2",
                head_sha = "86fadc736fc76303a82f8ba05feff0f77e942847",
                status = "in_progress",
                output = build_output(
                    title = "build failed",
                    summary = "failed",
                    text = _format_build_state(build_state),
                    annotations = annotations
                )
            )
            print(r)
    elif event.kind == "build_finished":
        print(_format_build_state(build_state))
        suggestions = [
            build_suggestion(
                path = "README.md",
                line = 7,
                suggested_code = "fixed line 5",
                message = "Lint: trailing whitespace",
            ),
        ]

        r = create_review(
            ctx,
            token = "",
            owner = "thesayyn",
            repo = "lint_example",
            pull_number = 1,
            body = "Lint findings",
            event = "COMMENT",
            comments = suggestions,
        )
        print(r)


def configure_builtins(ctx: ConfigContext):
    ctx.tasks.add(migrate)

    CI = ctx.std.env.var("BUILDKITE")

    # Read platform config from disk
    platform_config = read_platform_config(ctx.std.fs)
    # Read host config from environment
    host_config = read_host_config(ctx.std.env, ctx.std.io)

    # Generate bazelrc content
    flags = get_bazelrc_flags(
        platform_config = platform_config,
        host_config = host_config,
        bazel_version = "7.0.0",
    )

    # Debugging information
    if CI:
        print(platform_config)
        print(host_config)
        print(flags)

    user = ctx.std.env.var("USER")

    def flags(flags, type):
        if user != "thesayyn" and type in flags:
            flags += flags[type]
        return flags

    bessie_endpoint = platform_config.get("bessie_endpoint", None)
    def build_event_sinks():
        sinks = []
        if user != "thesayyn" and bessie_endpoint:
            sinks.append(bazel.build_events.grpc(
                uri = bessie_endpoint,
                metadata = {} # TODO: how does bessie authenticate?
            ))
        return sinks

    for task in ctx.tasks:
        if task.name == "build" and task.path.endswith("aspect/build.axl"):
            task.config.startup_flags = lambda f: flags(f, "startup")
            task.config.flags = lambda f: flags(f, "build")
            task.config.build_start = lambda: print("+++ :bazel: Building")
            task.config.build_event_sinks = build_event_sinks
            task.config.build_event = on_build_event