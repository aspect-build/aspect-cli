// @generated by protoc-gen-es v1.8.0 with parameter "keep_empty_files=true,target=js+dts,js_import_style=legacy_commonjs"
// @generated from file cli/core/bazel/analysis/analysis_v2.proto (package bazel, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Target as Target$1 } from "../query/build_pb.js";

/**
 * @generated from message bazel.ActionGraphContainer
 */
export declare class ActionGraphContainer extends Message<ActionGraphContainer> {
  /**
   * @generated from field: repeated bazel.Artifact artifacts = 1;
   */
  artifacts: Artifact[];

  /**
   * @generated from field: repeated bazel.Action actions = 2;
   */
  actions: Action[];

  /**
   * @generated from field: repeated bazel.Target targets = 3;
   */
  targets: Target[];

  /**
   * @generated from field: repeated bazel.DepSetOfFiles dep_set_of_files = 4;
   */
  depSetOfFiles: DepSetOfFiles[];

  /**
   * @generated from field: repeated bazel.Configuration configuration = 5;
   */
  configuration: Configuration[];

  /**
   * @generated from field: repeated bazel.AspectDescriptor aspect_descriptors = 6;
   */
  aspectDescriptors: AspectDescriptor[];

  /**
   * @generated from field: repeated bazel.RuleClass rule_classes = 7;
   */
  ruleClasses: RuleClass[];

  /**
   * @generated from field: repeated bazel.PathFragment path_fragments = 8;
   */
  pathFragments: PathFragment[];

  constructor(data?: PartialMessage<ActionGraphContainer>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.ActionGraphContainer";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActionGraphContainer;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActionGraphContainer;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActionGraphContainer;

  static equals(a: ActionGraphContainer | PlainMessage<ActionGraphContainer> | undefined, b: ActionGraphContainer | PlainMessage<ActionGraphContainer> | undefined): boolean;
}

/**
 * @generated from message bazel.Artifact
 */
export declare class Artifact extends Message<Artifact> {
  /**
   * @generated from field: uint32 id = 1;
   */
  id: number;

  /**
   * @generated from field: uint32 path_fragment_id = 2;
   */
  pathFragmentId: number;

  /**
   * @generated from field: bool is_tree_artifact = 3;
   */
  isTreeArtifact: boolean;

  constructor(data?: PartialMessage<Artifact>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.Artifact";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Artifact;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Artifact;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Artifact;

  static equals(a: Artifact | PlainMessage<Artifact> | undefined, b: Artifact | PlainMessage<Artifact> | undefined): boolean;
}

/**
 * @generated from message bazel.Action
 */
export declare class Action extends Message<Action> {
  /**
   * @generated from field: uint32 target_id = 1;
   */
  targetId: number;

  /**
   * @generated from field: repeated uint32 aspect_descriptor_ids = 2;
   */
  aspectDescriptorIds: number[];

  /**
   * @generated from field: string action_key = 3;
   */
  actionKey: string;

  /**
   * @generated from field: string mnemonic = 4;
   */
  mnemonic: string;

  /**
   * @generated from field: uint32 configuration_id = 5;
   */
  configurationId: number;

  /**
   * @generated from field: repeated string arguments = 6;
   */
  arguments: string[];

  /**
   * @generated from field: repeated bazel.KeyValuePair environment_variables = 7;
   */
  environmentVariables: KeyValuePair[];

  /**
   * @generated from field: repeated uint32 input_dep_set_ids = 8;
   */
  inputDepSetIds: number[];

  /**
   * @generated from field: repeated uint32 scheduling_dep_dep_set_ids = 20;
   */
  schedulingDepDepSetIds: number[];

  /**
   * @generated from field: repeated uint32 output_ids = 9;
   */
  outputIds: number[];

  /**
   * @generated from field: bool discovers_inputs = 10;
   */
  discoversInputs: boolean;

  /**
   * @generated from field: repeated bazel.KeyValuePair execution_info = 11;
   */
  executionInfo: KeyValuePair[];

  /**
   * @generated from field: repeated bazel.ParamFile param_files = 12;
   */
  paramFiles: ParamFile[];

  /**
   * @generated from field: uint32 primary_output_id = 13;
   */
  primaryOutputId: number;

  /**
   * @generated from field: string execution_platform = 14;
   */
  executionPlatform: string;

  /**
   * @generated from field: string template_content = 15;
   */
  templateContent: string;

  /**
   * @generated from field: repeated bazel.KeyValuePair substitutions = 16;
   */
  substitutions: KeyValuePair[];

  /**
   * @generated from field: string file_contents = 17;
   */
  fileContents: string;

  /**
   * @generated from field: string unresolved_symlink_target = 18;
   */
  unresolvedSymlinkTarget: string;

  /**
   * @generated from field: bool is_executable = 19;
   */
  isExecutable: boolean;

  constructor(data?: PartialMessage<Action>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.Action";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Action;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Action;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Action;

  static equals(a: Action | PlainMessage<Action> | undefined, b: Action | PlainMessage<Action> | undefined): boolean;
}

/**
 * @generated from message bazel.Target
 */
export declare class Target extends Message<Target> {
  /**
   * @generated from field: uint32 id = 1;
   */
  id: number;

  /**
   * @generated from field: string label = 2;
   */
  label: string;

  /**
   * @generated from field: uint32 rule_class_id = 3;
   */
  ruleClassId: number;

  constructor(data?: PartialMessage<Target>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.Target";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Target;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Target;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Target;

  static equals(a: Target | PlainMessage<Target> | undefined, b: Target | PlainMessage<Target> | undefined): boolean;
}

/**
 * @generated from message bazel.RuleClass
 */
export declare class RuleClass extends Message<RuleClass> {
  /**
   * @generated from field: uint32 id = 1;
   */
  id: number;

  /**
   * @generated from field: string name = 2;
   */
  name: string;

  constructor(data?: PartialMessage<RuleClass>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.RuleClass";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RuleClass;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RuleClass;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RuleClass;

  static equals(a: RuleClass | PlainMessage<RuleClass> | undefined, b: RuleClass | PlainMessage<RuleClass> | undefined): boolean;
}

/**
 * @generated from message bazel.AspectDescriptor
 */
export declare class AspectDescriptor extends Message<AspectDescriptor> {
  /**
   * @generated from field: uint32 id = 1;
   */
  id: number;

  /**
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * @generated from field: repeated bazel.KeyValuePair parameters = 3;
   */
  parameters: KeyValuePair[];

  constructor(data?: PartialMessage<AspectDescriptor>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.AspectDescriptor";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AspectDescriptor;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AspectDescriptor;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AspectDescriptor;

  static equals(a: AspectDescriptor | PlainMessage<AspectDescriptor> | undefined, b: AspectDescriptor | PlainMessage<AspectDescriptor> | undefined): boolean;
}

/**
 * @generated from message bazel.DepSetOfFiles
 */
export declare class DepSetOfFiles extends Message<DepSetOfFiles> {
  /**
   * @generated from field: uint32 id = 1;
   */
  id: number;

  /**
   * @generated from field: repeated uint32 transitive_dep_set_ids = 2;
   */
  transitiveDepSetIds: number[];

  /**
   * @generated from field: repeated uint32 direct_artifact_ids = 3;
   */
  directArtifactIds: number[];

  constructor(data?: PartialMessage<DepSetOfFiles>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.DepSetOfFiles";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DepSetOfFiles;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DepSetOfFiles;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DepSetOfFiles;

  static equals(a: DepSetOfFiles | PlainMessage<DepSetOfFiles> | undefined, b: DepSetOfFiles | PlainMessage<DepSetOfFiles> | undefined): boolean;
}

/**
 * @generated from message bazel.Configuration
 */
export declare class Configuration extends Message<Configuration> {
  /**
   * @generated from field: uint32 id = 1;
   */
  id: number;

  /**
   * @generated from field: string mnemonic = 2;
   */
  mnemonic: string;

  /**
   * @generated from field: string platform_name = 3;
   */
  platformName: string;

  /**
   * @generated from field: string checksum = 4;
   */
  checksum: string;

  /**
   * @generated from field: bool is_tool = 5;
   */
  isTool: boolean;

  /**
   * @generated from field: repeated bazel.Fragment fragments = 6;
   */
  fragments: Fragment[];

  /**
   * @generated from field: repeated bazel.FragmentOptions fragment_options = 7;
   */
  fragmentOptions: FragmentOptions[];

  constructor(data?: PartialMessage<Configuration>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.Configuration";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Configuration;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Configuration;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Configuration;

  static equals(a: Configuration | PlainMessage<Configuration> | undefined, b: Configuration | PlainMessage<Configuration> | undefined): boolean;
}

/**
 * @generated from message bazel.Fragment
 */
export declare class Fragment extends Message<Fragment> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: repeated string fragment_option_names = 2;
   */
  fragmentOptionNames: string[];

  constructor(data?: PartialMessage<Fragment>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.Fragment";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fragment;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fragment;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fragment;

  static equals(a: Fragment | PlainMessage<Fragment> | undefined, b: Fragment | PlainMessage<Fragment> | undefined): boolean;
}

/**
 * @generated from message bazel.FragmentOptions
 */
export declare class FragmentOptions extends Message<FragmentOptions> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: repeated bazel.Option options = 2;
   */
  options: Option[];

  constructor(data?: PartialMessage<FragmentOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.FragmentOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FragmentOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FragmentOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FragmentOptions;

  static equals(a: FragmentOptions | PlainMessage<FragmentOptions> | undefined, b: FragmentOptions | PlainMessage<FragmentOptions> | undefined): boolean;
}

/**
 * @generated from message bazel.Option
 */
export declare class Option extends Message<Option> {
  /**
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * @generated from field: optional string value = 2;
   */
  value?: string;

  constructor(data?: PartialMessage<Option>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.Option";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Option;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Option;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Option;

  static equals(a: Option | PlainMessage<Option> | undefined, b: Option | PlainMessage<Option> | undefined): boolean;
}

/**
 * @generated from message bazel.KeyValuePair
 */
export declare class KeyValuePair extends Message<KeyValuePair> {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * @generated from field: string value = 2;
   */
  value: string;

  constructor(data?: PartialMessage<KeyValuePair>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.KeyValuePair";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyValuePair;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyValuePair;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyValuePair;

  static equals(a: KeyValuePair | PlainMessage<KeyValuePair> | undefined, b: KeyValuePair | PlainMessage<KeyValuePair> | undefined): boolean;
}

/**
 * @generated from message bazel.ConfiguredTarget
 */
export declare class ConfiguredTarget extends Message<ConfiguredTarget> {
  /**
   * @generated from field: blaze_query_aspect_mirror.Target target = 1;
   */
  target?: Target$1;

  /**
   * @generated from field: bazel.Configuration configuration = 2 [deprecated = true];
   * @deprecated
   */
  configuration?: Configuration;

  /**
   * @generated from field: uint32 configuration_id = 3;
   */
  configurationId: number;

  constructor(data?: PartialMessage<ConfiguredTarget>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.ConfiguredTarget";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfiguredTarget;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfiguredTarget;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfiguredTarget;

  static equals(a: ConfiguredTarget | PlainMessage<ConfiguredTarget> | undefined, b: ConfiguredTarget | PlainMessage<ConfiguredTarget> | undefined): boolean;
}

/**
 * @generated from message bazel.CqueryResult
 */
export declare class CqueryResult extends Message<CqueryResult> {
  /**
   * @generated from field: repeated bazel.ConfiguredTarget results = 1;
   */
  results: ConfiguredTarget[];

  /**
   * @generated from field: repeated bazel.Configuration configurations = 2;
   */
  configurations: Configuration[];

  constructor(data?: PartialMessage<CqueryResult>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.CqueryResult";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CqueryResult;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CqueryResult;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CqueryResult;

  static equals(a: CqueryResult | PlainMessage<CqueryResult> | undefined, b: CqueryResult | PlainMessage<CqueryResult> | undefined): boolean;
}

/**
 * @generated from message bazel.ParamFile
 */
export declare class ParamFile extends Message<ParamFile> {
  /**
   * @generated from field: string exec_path = 1;
   */
  execPath: string;

  /**
   * @generated from field: repeated string arguments = 2;
   */
  arguments: string[];

  constructor(data?: PartialMessage<ParamFile>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.ParamFile";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ParamFile;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ParamFile;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ParamFile;

  static equals(a: ParamFile | PlainMessage<ParamFile> | undefined, b: ParamFile | PlainMessage<ParamFile> | undefined): boolean;
}

/**
 * @generated from message bazel.PathFragment
 */
export declare class PathFragment extends Message<PathFragment> {
  /**
   * @generated from field: uint32 id = 1;
   */
  id: number;

  /**
   * @generated from field: string label = 2;
   */
  label: string;

  /**
   * @generated from field: uint32 parent_id = 3;
   */
  parentId: number;

  constructor(data?: PartialMessage<PathFragment>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "bazel.PathFragment";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PathFragment;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PathFragment;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PathFragment;

  static equals(a: PathFragment | PlainMessage<PathFragment> | undefined, b: PathFragment | PlainMessage<PathFragment> | undefined): boolean;
}

