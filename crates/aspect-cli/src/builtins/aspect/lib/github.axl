"""
GitHub Check Runs Client Library

Client for creating and updating GitHub Check Runs via the GitHub API.
"""

DEFAULT_GITHUB_API = "https://api.github.com"


def _normalize_output(output):
    """
    Normalize output parameter to the required dict format.

    If output is a string, wraps it in a dict with title and summary.
    If output is already a dict, returns it as-is.
    """
    if output == None:
        return None
    if type(output) == "string":
        return {
            "title": "Check Run Output",
            "summary": output,
        }
    return output


def _do_request(ctx, method, url, token, payload = None):
    """
    Make an HTTP request to GitHub API.

    Args:
        ctx: Context with http()
        method: HTTP method ("POST" or "PATCH")
        url: Full URL to request
        token: GitHub token (PAT or Actions token)
        payload: Optional dict to send as JSON body

    Returns:
        (success: bool, status: int, body: dict or str)
    """
    http = ctx.http()

    headers = {
        "Authorization": "Bearer " + token,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json",
        "X-GitHub-Api-Version": "2022-11-28",
    }

    if method == "POST":
        response = http.post(
            url = url,
            headers = headers,
            data = json.encode(payload) if payload else None,
        ).block()
    elif method == "PATCH":
        response = http.patch(
            url = url,
            headers = headers,
            data = json.encode(payload) if payload else None,
        ).block()
    else:
        return (False, 0, "unsupported method: " + method)

    success = response.status >= 200 and response.status < 300

    # Try to parse response as JSON
    body = response.body
    if body:
        body = json.decode(body)

    return (success, response.status, body)


def _do_get_request(ctx, url, token):
    """
    Make a GET request to GitHub API.

    Args:
        ctx: Context with http()
        url: Full URL to request
        token: GitHub token (PAT or Actions token)

    Returns:
        (success: bool, status: int, body: dict or str)
    """
    http = ctx.http()

    headers = {
        "Authorization": "Bearer " + token,
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
    }

    response = http.get(
        url = url,
        headers = headers,
    ).block()

    success = response.status >= 200 and response.status < 300

    body = response.body
    if body:
        body = json.decode(body)

    return (success, response.status, body)


def _do_delete_request(ctx, url, token):
    """
    Make a DELETE request to GitHub API.

    Args:
        ctx: Context with http()
        url: Full URL to request
        token: GitHub token (PAT or Actions token)

    Returns:
        (success: bool, status: int, body: str or None)
    """
    http = ctx.http()

    headers = {
        "Authorization": "Bearer " + token,
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
    }

    response = http.delete(
        url = url,
        headers = headers,
    ).block()

    success = response.status >= 200 and response.status < 300

    return (success, response.status, response.body)


def get_pull_request(ctx, token, owner, repo, pull_number, api_base = DEFAULT_GITHUB_API):
    """
    Get a pull request by number.

    Args:
        ctx: Context with http()
        token: GitHub token
        owner: Repository owner
        repo: Repository name
        pull_number: The PR number
        api_base: GitHub API base URL

    Returns:
        dict with "success" (bool), "pull_request" (dict) on success
        dict with "success" (False), "error" (str), "status" (int) on failure
    """
    url = api_base + "/repos/" + owner + "/" + repo + "/pulls/" + str(pull_number)

    success, status_code, body = _do_get_request(ctx, url, token)

    if success:
        return {
            "success": True,
            "pull_request": body,
        }

    error_msg = "request failed: " + str(status_code)
    if body and type(body) == "dict" and body.get("message"):
        error_msg = error_msg + " - " + body["message"]

    return {"success": False, "error": error_msg, "status": status_code}


def list_review_comments(ctx, token, owner, repo, pull_number, api_base = DEFAULT_GITHUB_API):
    """
    List all review comments on a pull request.

    Handles pagination to retrieve all comments.

    Args:
        ctx: Context with http()
        token: GitHub token
        owner: Repository owner
        repo: Repository name
        pull_number: The PR number
        api_base: GitHub API base URL

    Returns:
        dict with "success" (bool), "comments" (list) on success
        dict with "success" (False), "error" (str), "status" (int) on failure
    """
    all_comments = []

    for page in range(1, 101):  # max 100 pages (10,000 comments)
        url = api_base + "/repos/" + owner + "/" + repo + "/pulls/" + str(pull_number) + "/comments?per_page=100&page=" + str(page)

        success, status_code, body = _do_get_request(ctx, url, token)

        if not success:
            error_msg = "request failed: " + str(status_code)
            if body and type(body) == "dict" and body.get("message"):
                error_msg = error_msg + " - " + body["message"]
            return {"success": False, "error": error_msg, "status": status_code}

        if not body or len(body) == 0:
            break

        all_comments.extend(body)

        if len(body) < 100:
            break

    return {
        "success": True,
        "comments": all_comments,
    }


def delete_review_comment(ctx, token, owner, repo, comment_id, api_base = DEFAULT_GITHUB_API):
    """
    Delete a review comment on a pull request.

    Args:
        ctx: Context with http()
        token: GitHub token
        owner: Repository owner
        repo: Repository name
        comment_id: The comment ID to delete
        api_base: GitHub API base URL

    Returns:
        dict with "success" (bool) on success
        dict with "success" (False), "error" (str), "status" (int) on failure
    """
    url = api_base + "/repos/" + owner + "/" + repo + "/pulls/comments/" + str(comment_id)

    success, status_code, body = _do_delete_request(ctx, url, token)

    if success:
        return {"success": True}

    error_msg = "request failed: " + str(status_code)
    return {"success": False, "error": error_msg, "status": status_code}


def list_pull_request_files(ctx, token, owner, repo, pull_number, api_base = DEFAULT_GITHUB_API):
    """
    List files changed in a pull request.

    Handles pagination to retrieve all files.

    Args:
        ctx: Context with http()
        token: GitHub token
        owner: Repository owner
        repo: Repository name
        pull_number: The PR number
        api_base: GitHub API base URL

    Returns:
        dict with "success" (bool), "files" (list) on success
        dict with "success" (False), "error" (str), "status" (int) on failure
    """
    all_files = []

    for page in range(1, 101):  # max 100 pages (10,000 files)
        url = api_base + "/repos/" + owner + "/" + repo + "/pulls/" + str(pull_number) + "/files?per_page=100&page=" + str(page)

        success, status_code, body = _do_get_request(ctx, url, token)

        if not success:
            error_msg = "request failed: " + str(status_code)
            if body and type(body) == "dict" and body.get("message"):
                error_msg = error_msg + " - " + body["message"]
            return {"success": False, "error": error_msg, "status": status_code}

        if not body or len(body) == 0:
            break

        all_files.extend(body)

        if len(body) < 100:
            break

    return {
        "success": True,
        "files": all_files,
    }


def create_check_run(ctx, token, owner, repo, name, head_sha, status = None, output = None, details_url = None, external_id = None, started_at = None, api_base = DEFAULT_GITHUB_API):
    """
    Create a new check run on a commit.

    Args:
        ctx: Context with http()
        token: GitHub token (PAT or GITHUB_TOKEN from Actions)
        owner: Repository owner
        repo: Repository name
        name: Name of the check run
        head_sha: The SHA of the commit to create the check on
        status: Optional status ("queued", "in_progress", "completed")
        output: Optional dict with "title", "summary", and optionally "text", "annotations"
        details_url: Optional URL for more details
        external_id: Optional external identifier
        started_at: Optional ISO 8601 timestamp
        api_base: GitHub API base URL (default: https://api.github.com)

    Returns:
        dict with "success" (bool), "check_run_id" (int), "html_url" (str) on success
        dict with "success" (False), "error" (str), "status" (int) on failure
    """
    url = api_base + "/repos/" + owner + "/" + repo + "/check-runs"

    payload = {
        "name": name,
        "head_sha": head_sha,
    }

    if status:
        payload["status"] = status
    if output:
        payload["output"] = output
    if details_url:
        payload["details_url"] = details_url
    if external_id:
        payload["external_id"] = external_id
    if started_at:
        payload["started_at"] = started_at

    success, status_code, body = _do_request(ctx, "POST", url, token, payload)

    if success:
        return {
            "success": True,
            "check_run_id": body.get("id"),
            "html_url": body.get("html_url"),
            "response": body,
        }

    error_msg = "request failed: " + str(status_code)
    if body and type(body) == "dict" and body.get("message"):
        error_msg = error_msg + " - " + body["message"]

    return {"success": False, "error": error_msg, "status": status_code}


def update_check_run(ctx, token, owner, repo, check_run_id, status = None, conclusion = None, output = None, details_url = None, completed_at = None, api_base = DEFAULT_GITHUB_API):
    """
    Update an existing check run.

    Args:
        ctx: Context with http()
        token: GitHub token
        owner: Repository owner
        repo: Repository name
        check_run_id: The ID of the check run to update
        status: Optional new status ("queued", "in_progress", "completed")
        conclusion: Required if status is "completed". One of:
                    "action_required", "cancelled", "failure", "neutral",
                    "success", "skipped", "stale", "timed_out"
        output: Optional dict with "title", "summary", and optionally "text", "annotations"
        details_url: Optional URL for more details
        completed_at: Optional ISO 8601 timestamp (required if conclusion is set)
        api_base: GitHub API base URL

    Returns:
        dict with "success" (bool), "check_run_id" (int) on success
        dict with "success" (False), "error" (str), "status" (int) on failure
    """
    url = api_base + "/repos/" + owner + "/" + repo + "/check-runs/" + str(check_run_id)

    payload = {}

    if status:
        payload["status"] = status
    if conclusion:
        payload["conclusion"] = conclusion
    if output:
        payload["output"] = output
    if details_url:
        payload["details_url"] = details_url
    if completed_at:
        payload["completed_at"] = completed_at

    success, status_code, body = _do_request(ctx, "PATCH", url, token, payload)

    if success:
        return {
            "success": True,
            "check_run_id": body.get("id"),
            "html_url": body.get("html_url"),
            "response": body,
        }

    error_msg = "request failed: " + str(status_code)
    if body and type(body) == "dict" and body.get("message"):
        error_msg = error_msg + " - " + body["message"]

    return {"success": False, "error": error_msg, "status": status_code}


def complete_check_run(ctx, token, owner, repo, check_run_id, conclusion, output = None, api_base = DEFAULT_GITHUB_API):
    """
    Complete a check run with a conclusion.

    Convenience wrapper around update_check_run for completing checks.

    Args:
        ctx: Context with http()
        token: GitHub token
        owner: Repository owner
        repo: Repository name
        check_run_id: The ID of the check run to complete
        conclusion: One of: "action_required", "cancelled", "failure",
                    "neutral", "success", "skipped", "stale", "timed_out"
        output: Optional dict with "title", "summary"
        api_base: GitHub API base URL

    Returns:
        dict with "success" (bool), "check_run_id" (int) on success
        dict with "success" (False), "error" (str), "status" (int) on failure
    """
    return update_check_run(
        ctx,
        token,
        owner,
        repo,
        check_run_id,
        status = "completed",
        conclusion = conclusion,
        output = output,
        api_base = api_base,
    )


def build_output(title, summary, text = None, annotations = None):
    """
    Helper to build an output object for check runs.

    Args:
        title: Title of the check run output
        summary: Summary (supports markdown)
        text: Optional detailed text (supports markdown)
        annotations: Optional list of annotation dicts

    Returns:
        dict suitable for the "output" parameter
    """
    output = {
        "title": title,
        "summary": summary,
    }
    if text:
        output["text"] = text
    if annotations:
        output["annotations"] = annotations
    return output


def build_annotation(path, start_line, end_line, message, annotation_level = "warning", start_column = None, end_column = None, title = None, raw_details = None):
    """
    Helper to build an annotation for check run output.

    Args:
        path: Path of the file to annotate (relative to repo root)
        start_line: Start line of the annotation
        end_line: End line of the annotation
        message: Short description of the feedback
        annotation_level: "notice", "warning", or "failure" (default: "warning")
        start_column: Optional start column
        end_column: Optional end column
        title: Optional title for the annotation
        raw_details: Optional raw details string

    Returns:
        dict suitable for the "annotations" list
    """
    annotation = {
        "path": path,
        "start_line": start_line,
        "end_line": end_line,
        "annotation_level": annotation_level,
        "message": message,
    }
    if start_column:
        annotation["start_column"] = start_column
    if end_column:
        annotation["end_column"] = end_column
    if title:
        annotation["title"] = title
    if raw_details:
        annotation["raw_details"] = raw_details
    return annotation


# =============================================================================
# Pull Request Review Comments API
# =============================================================================

def create_review(ctx, token, owner, repo, pull_number, body = None, event = "COMMENT", comments = None, commit_id = None, api_base = DEFAULT_GITHUB_API):
    """
    Create a pull request review with optional comments.

    This creates comments that appear directly on the PR diff page.

    Args:
        ctx: Context with http()
        token: GitHub token
        owner: Repository owner
        repo: Repository name
        pull_number: The PR number
        body: Optional review body text (shown at top of review)
        event: Review action - "APPROVE", "REQUEST_CHANGES", or "COMMENT" (default)
        comments: Optional list of review comment dicts (use build_review_comment)
        commit_id: Optional commit SHA to review (defaults to PR head)
        api_base: GitHub API base URL

    Returns:
        dict with "success" (bool), "review_id" (int) on success
        dict with "success" (False), "error" (str), "status" (int) on failure
    """
    url = api_base + "/repos/" + owner + "/" + repo + "/pulls/" + str(pull_number) + "/reviews"

    payload = {
        "event": event,
    }

    if body:
        payload["body"] = body
    if comments:
        payload["comments"] = comments
    if commit_id:
        payload["commit_id"] = commit_id

    success, status_code, response_body = _do_request(ctx, "POST", url, token, payload)

    if success:
        return {
            "success": True,
            "review_id": response_body.get("id"),
            "html_url": response_body.get("html_url"),
            "response": response_body,
        }

    error_msg = "request failed: " + str(status_code)
    if response_body and type(response_body) == "dict" and response_body.get("message"):
        error_msg = error_msg + " - " + response_body["message"]

    return {"success": False, "error": error_msg, "status": status_code}


def create_review_comment(ctx, token, owner, repo, pull_number, body, path, line = None, commit_id = None, side = "RIGHT", start_line = None, start_side = None, subject_type = None, api_base = DEFAULT_GITHUB_API):
    """
    Create a single review comment on a PR diff.

    Args:
        ctx: Context with http()
        token: GitHub token
        owner: Repository owner
        repo: Repository name
        pull_number: The PR number
        body: The comment text (supports markdown)
        path: File path relative to repo root
        line: Line number in the diff to comment on (required unless using subject_type="file")
        commit_id: Optional commit SHA (defaults to PR head)
        side: "LEFT" (deletion) or "RIGHT" (addition, default)
        start_line: For multi-line comments, the first line
        start_side: Side for start_line ("LEFT" or "RIGHT")
        subject_type: "line" (default) or "file" for file-level comments
        api_base: GitHub API base URL

    Returns:
        dict with "success" (bool), "comment_id" (int) on success
        dict with "success" (False), "error" (str), "status" (int) on failure
    """
    url = api_base + "/repos/" + owner + "/" + repo + "/pulls/" + str(pull_number) + "/comments"

    payload = {
        "body": body,
        "path": path,
    }

    if subject_type:
        payload["subject_type"] = subject_type
    if line:
        payload["line"] = line
        payload["side"] = side
    if commit_id:
        payload["commit_id"] = commit_id
    if start_line:
        payload["start_line"] = start_line
    if start_side:
        payload["start_side"] = start_side

    success, status_code, response_body = _do_request(ctx, "POST", url, token, payload)

    if success:
        return {
            "success": True,
            "comment_id": response_body.get("id"),
            "html_url": response_body.get("html_url"),
            "response": response_body,
        }

    error_msg = "request failed: " + str(status_code)
    if response_body and type(response_body) == "dict" and response_body.get("message"):
        error_msg = error_msg + " - " + response_body["message"]

    return {"success": False, "error": error_msg, "status": status_code}


def build_review_comment(path, body, line = None, side = "RIGHT", start_line = None, start_side = None):
    """
    Helper to build a review comment for use with create_review.

    Args:
        path: File path relative to repo root
        body: Comment text (supports markdown)
        line: Line number in the diff (the ending line for multi-line)
        side: "LEFT" (deletion) or "RIGHT" (addition, default)
        start_line: For multi-line comments, the starting line
        start_side: Side for start_line

    Returns:
        dict suitable for the "comments" list in create_review
    """
    comment = {
        "path": path,
        "body": body,
    }
    if line:
        comment["line"] = line
        comment["side"] = side
    if start_line:
        comment["start_line"] = start_line
    if start_side:
        comment["start_side"] = start_side
    return comment


def build_suggestion(path, line, suggested_code, message = None, start_line = None):
    """
    Helper to build a code suggestion comment that shows "Apply suggestion" button.

    Args:
        path: File path relative to repo root
        line: Line number to suggest replacement for (end line if multi-line)
        suggested_code: The replacement code (what the line(s) should become)
        message: Optional message to show above the suggestion
        start_line: For multi-line suggestions, the starting line

    Returns:
        dict suitable for the "comments" list in create_review

    Example:
        # Single line suggestion
        build_suggestion(
            path = "src/main.py",
            line = 42,
            suggested_code = "const FOO = 'bar'",
            message = "Use const instead of let for constants",
        )

        # Multi-line suggestion (replace lines 10-12 with new code)
        build_suggestion(
            path = "src/main.py",
            start_line = 10,
            line = 12,
            suggested_code = "function foo() {\\n  return bar\\n}",
        )
    """
    body = ""
    if message:
        body = message + "\n\n"
    body = body + "```suggestion\n" + suggested_code + "\n```"

    comment = {
        "path": path,
        "body": body,
        "line": line,
        "side": "RIGHT",
    }
    if start_line:
        comment["start_line"] = start_line
        comment["start_side"] = "RIGHT"
    return comment


def create_suggestion(ctx, token, owner, repo, pull_number, path, line, suggested_code, message = None, start_line = None, commit_id = None, api_base = DEFAULT_GITHUB_API):
    """
    Create a single code suggestion on a PR.

    This creates an "Apply suggestion" button on the PR diff.

    Args:
        ctx: Context with http()
        token: GitHub token
        owner: Repository owner
        repo: Repository name
        pull_number: The PR number
        path: File path relative to repo root
        line: Line number to suggest replacement for
        suggested_code: The replacement code
        message: Optional message above the suggestion
        start_line: For multi-line suggestions, the starting line
        commit_id: Optional commit SHA (defaults to PR head)
        api_base: GitHub API base URL

    Returns:
        dict with "success" (bool), "comment_id" (int) on success
        dict with "success" (False), "error" (str), "status" (int) on failure
    """
    body = ""
    if message:
        body = message + "\n\n"
    body = body + "```suggestion\n" + suggested_code + "\n```"

    return create_review_comment(
        ctx, token, owner, repo, pull_number,
        body = body,
        path = path,
        line = line,
        commit_id = commit_id,
        side = "RIGHT",
        start_line = start_line,
        start_side = "RIGHT" if start_line else None,
        api_base = api_base,
    )
