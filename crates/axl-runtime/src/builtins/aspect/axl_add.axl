"""
Add AXL dependencies to MODULE.aspect from GitHub releases.

Usage:
  aspect axl add gh:owner/repo          # adds latest release
  aspect axl add gh:owner/repo@latest   # same as above
  aspect axl add gh:owner/repo@v1.0.0   # adds specific version
"""

# ANSI escape codes for terminal UI
ORANGE = "\033[38;5;208m"
GREEN = "\033[32m"
DIM = "\033[2m"
BOLD = "\033[1m"
CYAN = "\033[36m"
YELLOW = "\033[33m"
RESET = "\033[0m"
CLEAR_LINE = "\033[2K"
MOVE_UP = "\033[1A"

def progress_bar(current: int, total: int, width: int = 30) -> str:
    """Generate an orange progress bar string."""
    filled = int(width * current / total)
    bar = "â–ª" * filled + "â–«" * (width - filled)
    percent = int(100 * current / total)
    return ORANGE + "[" + bar + "]" + RESET + " " + str(percent) + "%"

def show_phase(ctx: TaskContext, phases: list, current: int):
    """Display phases with checkmarks and progress bar."""
    if not ctx.std.io.stdout.is_tty:
        # Non-TTY: just print current phase
        print(phases[current] + "...")
        return

    io = ctx.std.io

    # Move up and clear previous output (on update calls)
    if current > 0:
        num_lines = len(phases) + 1  # phases + progress bar
        # Clear current line first (progress bar has no trailing newline)
        io.stdout.write("\r" + CLEAR_LINE)
        # Move up and clear remaining lines
        for _ in range(num_lines - 1):
            io.stdout.write(MOVE_UP + CLEAR_LINE)

    lines = []
    for i, phase in enumerate(phases):
        if i < current:
            lines.append(GREEN + "âœ“" + RESET + " " + phase)
        elif i == current:
            lines.append("  " + phase + "...")
        else:
            lines.append(DIM + "  " + phase + RESET)

    # Write phases and progress bar
    output = "\n".join(lines) + "\n"
    output += progress_bar(current + 1, len(phases))
    io.stdout.write(output)
    io.stdout.flush()

def clear_progress(ctx: TaskContext, num_lines: int):
    """Clear progress display lines."""
    if not ctx.std.io.stdout.is_tty:
        return
    io = ctx.std.io
    # Clear current line first (progress bar has no trailing newline)
    io.stdout.write("\r" + CLEAR_LINE)
    # Move up and clear remaining lines
    for _ in range(num_lines - 1):
        io.stdout.write(MOVE_UP + CLEAR_LINE)
    io.stdout.write("\r")
    io.stdout.flush()

def confirm(ctx: TaskContext, message: str) -> bool:
    """Ask for user confirmation. Returns True if confirmed."""
    if not ctx.std.io.stdout.is_tty:
        return True  # Auto-confirm in non-TTY mode

    ctx.std.io.stdout.write(message + " [y/N]: ")
    ctx.std.io.stdout.flush()
    response = ctx.std.io.stdin.read(1).decode().lower()
    return response == "y"

def parse_dep_spec(spec: str) -> dict:
    """
    Parse a dependency specification like 'gh:owner/repo@version'.

    Returns a dict with keys: source, owner, repo, version
    """
    if not spec.startswith("gh:"):
        fail("Only GitHub dependencies (gh:owner/repo) are supported currently")

    # Remove the 'gh:' prefix
    remainder = spec[3:]

    # Split by @ to get version
    version = "latest"
    if "@" in remainder:
        parts = remainder.split("@")
        remainder = parts[0]
        version = parts[1] if len(parts) > 1 and parts[1] else "latest"

    # Split by / to get owner and repo
    if "/" not in remainder:
        fail("Invalid dependency format. Expected: gh:owner/repo[@version]")

    parts = remainder.split("/")
    if len(parts) != 2:
        fail("Invalid dependency format. Expected: gh:owner/repo[@version]")

    owner = parts[0]
    repo = parts[1]

    if not owner or not repo:
        fail("Owner and repo cannot be empty")

    return {
        "source": "github",
        "owner": owner,
        "repo": repo,
        "version": version,
    }

def get_github_headers() -> dict:
    """Return headers for GitHub API requests."""
    return {
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
        "User-Agent": "AXL-CLI",
    }

def fetch_latest_release(ctx: TaskContext, owner: str, repo: str) -> dict:
    """Fetch the latest release from GitHub API."""
    url = "https://api.github.com/repos/" + owner + "/" + repo + "/releases/latest"
    response = ctx.http().get(url = url, headers = get_github_headers()).block()

    if response.status == 404:
        fail("Repository " + owner + "/" + repo + " not found or has no releases")

    if response.status != 200:
        fail("Failed to fetch release info: HTTP " + str(response.status))

    if not response.body:
        fail("Empty response body from GitHub API")

    return json.decode(response.body)

def fetch_release_by_tag(ctx: TaskContext, owner: str, repo: str, tag: str) -> dict:
    """Fetch a specific release by tag from GitHub API."""
    url = "https://api.github.com/repos/" + owner + "/" + repo + "/releases/tags/" + tag
    response = ctx.http().get(url = url, headers = get_github_headers()).block()

    if response.status == 404:
        # Release not found - try to verify the tag exists and use it directly
        return fetch_tag_as_release(ctx, owner, repo, tag)

    if response.status != 200:
        fail("Failed to fetch release info: HTTP " + str(response.status))

    return json.decode(response.body)

def fetch_tag_as_release(ctx: TaskContext, owner: str, repo: str, tag: str) -> dict:
    """Fetch tag info and create a synthetic release object for tags without releases."""
    # Check if the tag exists by trying to fetch it
    url = "https://api.github.com/repos/" + owner + "/" + repo + "/git/refs/tags/" + tag
    response = ctx.http().get(url = url, headers = get_github_headers()).block()

    if response.status == 404:
        fail("Tag " + tag + " not found in " + owner + "/" + repo)

    if response.status != 200:
        fail("Failed to fetch tag info: HTTP " + str(response.status))

    # Create a synthetic release object with the tag name
    return {
        "tag_name": tag,
        "author": {"login": "unknown"},
    }

def compute_integrity(ctx: TaskContext, url: str, temp_file: str) -> str:
    """
    Download a file and compute its SHA512 integrity hash in SSRI format.
    """
    # Download the file
    ctx.http().download(url = url, output = temp_file, mode = 0o644, headers = get_github_headers()).block()

    # Compute SHA512 and base64 encode using a shell command
    # Using sh -c to pipe the commands together
    child = ctx.std.process.command("sh").args([
        "-c",
        "openssl dgst -sha512 -binary '" + temp_file + "' | openssl base64 -A"
    ]).stdout("piped").stderr("piped").spawn()

    base64_hash = child.stdout().read_to_string().strip()
    stderr_output = child.stderr().read_to_string()
    status = child.wait()

    if status.code != 0:
        fail("Failed to compute hash: " + stderr_output)

    # Clean up temp file
    ctx.std.fs.remove_file(temp_file)

    return "sha512-" + base64_hash

def sanitize_module_name(name: str) -> str:
    """Convert a repository name to a valid module name."""
    # Replace hyphens with underscores and ensure it's a valid identifier
    return name.replace("-", "_").lower()

def generate_axl_archive_dep(name: str, url: str, integrity: str, strip_prefix: str) -> str:
    """Generate the axl_archive_dep() call to add to MODULE.aspect."""
    lines = [
        "",
        "axl_archive_dep(",
        "    name = \"" + name + "\",",
        "    urls = [\"" + url + "\"],",
        "    integrity = \"" + integrity + "\",",
        "    strip_prefix = \"" + strip_prefix + "\",",
        "    auto_use_tasks = True,",
        "    dev = True,",
        ")",
    ]
    return "\n".join(lines)

def read_module_aspect(ctx: TaskContext) -> str:
    """Read the current MODULE.aspect file content."""
    module_path = ctx.std.env.root_dir() + "/MODULE.aspect"

    if ctx.std.fs.exists(module_path):
        return ctx.std.fs.read_to_string(module_path)

    return ""

def write_module_aspect(ctx: TaskContext, content: str):
    """Write content to MODULE.aspect file."""
    module_path = ctx.std.env.root_dir() + "/MODULE.aspect"
    ctx.std.fs.write(module_path, content)

def check_existing_dep(content: str, name: str) -> bool:
    """Check if a dependency with this name already exists."""
    # Simple check for the name in quotes
    pattern = "name = \"" + name + "\""
    return pattern in content

def impl(ctx: TaskContext) -> int:
    if len(ctx.args.dep_spec) == 0:
        print("Error: No dependency specification provided")
        print("")
        print("Usage:")
        print("  aspect axl add gh:owner/repo          # adds latest release")
        print("  aspect axl add gh:owner/repo@latest   # same as above")
        print("  aspect axl add gh:owner/repo@v1.0.0   # adds specific version")
        return 1

    spec = ctx.args.dep_spec[0]

    # Parse the dependency spec
    parsed = parse_dep_spec(spec)
    owner = parsed["owner"]
    repo = parsed["repo"]
    version = parsed["version"]

    # Determine the module name (can be overridden with --name flag)
    module_name = ctx.args.name if ctx.args.name else sanitize_module_name(repo)

    # Check if dependency already exists
    current_content = read_module_aspect(ctx)
    if check_existing_dep(current_content, module_name):
        print("Error: A dependency named '" + module_name + "' already exists in MODULE.aspect")
        print("Use a different name with --name=<name> or remove the existing dependency first")
        return 1

    # Define phases for progress display
    phases = [
        "Querying GitHub for " + ("latest release" if version == "latest" else version),
        "Downloading and computing checksum",
        "Adding to MODULE.aspect"
    ]

    # Phase 1: Fetch release info from GitHub
    show_phase(ctx, phases, 0)
    if version == "latest":
        release = fetch_latest_release(ctx, owner, repo)
    else:
        release = fetch_release_by_tag(ctx, owner, repo, version)

    tag_name = release["tag_name"]

    # Use the direct GitHub archive URL format (more reliable than API URL)
    tarball_url = "https://github.com/" + owner + "/" + repo + "/archive/refs/tags/" + tag_name + ".tar.gz"

    # The strip_prefix is: repo-tag (without the 'v' prefix if present)
    # GitHub's tarball extracts to: {repo}-{tag_without_v}/
    tag_for_prefix = tag_name
    if tag_for_prefix.startswith("v"):
        tag_for_prefix = tag_for_prefix[1:]
    strip_prefix = repo + "-" + tag_for_prefix

    # Phase 2: Compute integrity hash
    show_phase(ctx, phases, 1)
    temp_dir = ctx.std.env.temp_dir()
    temp_file = temp_dir + "/axl_add_" + module_name + ".tar.gz"
    integrity = compute_integrity(ctx, tarball_url, temp_file)

    # Clear progress display for confirmation
    clear_progress(ctx, len(phases) + 1)

    # Get author info from release
    author_login = release["author"]["login"] if "author" in release else "unknown"
    author_url = release["author"]["html_url"] if "author" in release else ""

    # Confirmation (only for latest version, unless --yes flag is set)
    if version == "latest" and not ctx.args.yes:
        print("")
        print(BOLD + ORANGE + "ğŸ“¦ Release" + RESET)
        print(DIM + "   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" + RESET)
        print(DIM + "   Version   " + RESET + BOLD + tag_name + RESET)
        print(DIM + "   Author    " + RESET + author_login + (CYAN + " <" + author_url + ">" + RESET if author_url else ""))
        print(DIM + "   Integrity " + RESET + DIM + integrity + RESET)
        print("")
        if not confirm(ctx, YELLOW + "?" + RESET + " Add this dependency to MODULE.aspect"):
            print(DIM + "Cancelled." + RESET)
            return 1

    # Phase 3: Add to MODULE.aspect
    show_phase(ctx, phases, 2)

    # Generate the axl_archive_dep call
    dep_code = generate_axl_archive_dep(module_name, tarball_url, integrity, strip_prefix)

    # Append to MODULE.aspect
    new_content = current_content.rstrip() + "\n" + dep_code + "\n"
    write_module_aspect(ctx, new_content)

    # Clear progress and show success
    clear_progress(ctx, len(phases) + 1)
    print("ğŸ“ Added " + module_name + " (" + tag_name + ") to MODULE.aspect")
    return 0

add = task(
    group = ["axl"],
    description = "Add an AXL dependency to MODULE.aspect",
    implementation = impl,
    args = {
        "dep_spec": args.positional(),
        "name": args.string(),
        "yes": args.boolean(default = False),
    }
)
