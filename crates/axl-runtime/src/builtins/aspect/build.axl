"""
A default 'build' task that wraps a 'bazel build' command.
"""
load("./bazel.axl", "default_retry")

BuildConfig = spec(
    # Declarative data — composable, zero-cost reads
    extra_flags = attr(list[str], []),
    extra_startup_flags = attr(list[str], []),
    build_event_sinks = attr(list[bazel.build.BuildEventSink], []),

    # Optional transforms — only called when set
    flags = attr(typing.Callable[[list[str]], list[str]] | None, None),
    startup_flags = attr(typing.Callable[[list[str]], list[str]] | None, None),

    # Lifecycle — only called when set
    build_start = attr(typing.Callable[[], None] | None, None),
    build_event = attr(typing.Callable[[dict, str, str], None] | None, None),
    build_retry = attr(typing.Callable[[int], bool], default_retry),
    build_end = attr(typing.Callable[[int], None] | None, None),
)

def _collect_bes_from_args(ctx):
    """Collect BES sinks from CLI args (--bes_backend/--bes_header)."""
    sinks = []
    for bes_backend in ctx.args.bes_backend:
        metadata = {}
        for bes_header in ctx.args.bes_header:
            (k, _, v) = bes_header.partition("=")
            metadata[k] = v
        sinks.append(
            bazel.build_events.grpc(
                uri = bes_backend,
                metadata = metadata,
            )
        )
    return sinks

def impl(ctx: TaskContext) -> int:
    # Flags: accumulate data, then optionally transform
    flags = ["--isatty=" + str(int(ctx.std.io.stdout.is_tty))]
    flags.extend(ctx.args.bazel_flag)
    flags.extend(ctx.config.extra_flags)
    if ctx.config.flags:
        flags = ctx.config.flags(flags)

    startup_flags = list(ctx.args.bazel_startup_flag)
    startup_flags.extend(ctx.config.extra_startup_flags)
    if ctx.config.startup_flags:
        startup_flags = ctx.config.startup_flags(startup_flags)

    # BES: merge arg-based sinks with config sinks
    build_events = _collect_bes_from_args(ctx)
    if ctx.config.build_event_sinks:
        build_events.extend(ctx.config.build_event_sinks)

    # Coerce to bool/list for ctx.bazel.build:
    # - non-empty list → stream to those sinks + build_events() iterator.
    # - True → stream without explicit sinks (build_event handler only)
    # - False → no BEP stream at all
    if not build_events:
        if ctx.config.build_event:
            build_events = True
        else:
            build_events = False

    if ctx.config.build_start:
        ctx.config.build_start()

    for _ in range(10):
        build = ctx.bazel.build(
            build_events = build_events,
            flags = flags,
            startup_flags = startup_flags,
            *ctx.args.target_pattern,
        )

        if ctx.config.build_event:
            handler = ctx.config.build_event
            state = {}
            for event in build.build_events():
                handler(ctx, state, event)

        build_status = build.wait()

        if build_status.code == 0 or not ctx.config.build_retry(build_status.code):
            break

    if ctx.config.build_end:
        ctx.config.build_end(build_status.code)

    return build_status.code

build = task(
    implementation = impl,
    config = BuildConfig,
    args = {
        "target_pattern": args.positional(minimum = 1, maximum = 512, default = ["..."]),
        "bazel_flag": args.string_list(),
        "bazel_startup_flag": args.string_list(),
        "remote_executor": args.string(),
        "remote_cache": args.string(),
        "bes_backend": args.string_list(),
        "bes_header": args.string_list(),
    },
)
