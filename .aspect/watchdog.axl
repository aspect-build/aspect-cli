load("@watchdog/watchdog.axl", "watchdog")
load("@watchdog/protocol.axl", "CAP", "CYCLE", "SOURCE_FILE", "Protocol")

def sleep(ctx: task_context, secs):
    cmd = ctx.std.process.command("sleep")
    cmd.arg(str(secs))
    cmd.spawn().wait()

def get_terminal_size(ctx: task_context):
    cmd = ctx.std.process.command("stty")
    cmd.arg("size")
    cmd.stdout("piped")
    output = cmd.spawn().wait_with_output()
    rows, cols = output.stdout.strip().split(" ", 1)
    return (int(rows), int(cols))


def watch_loop(ctx, apdu: dict, id: int):
    # if apdu.get("is_fresh_instance", False):
    #     return True
    #

    # files = apdu.get("files", [])
    # if files:
    #     print("Following files have changed:")
    #     for file in files:
    #         print("\t" + file["name"])

    (rows, cols) = get_terminal_size(ctx)

    out = ctx.std.io.stdout

    message = "üê∂ Detected changes, rerunning..."
    pos = cols-len(message)-10
    out.write(f"\033[2J\033[H\033[2;{pos}H\033[K")
    out.write(message)
    out.flush()

    sleep(ctx, 1)

    # Clear the terminal
    out.write("\033[2J\033[H")
    out.write("\n")
    out.flush()

    build = ctx.bazel.build(
         events = True,
         bazel_flags = ["--isatty=1"],
         *ctx.args.target
    )

    for event in build.events():
        if event.kind == "progress":
            out.write(event.payload.stdout)
            out.write(event.payload.stderr)

    out.write("\033[1F\033[6C")
    out.write("Build finished.")
    out.flush()

    message = "üê∂ Waiting for changes..."
    pos = cols-len(message)-10
    out.write(f"\033[2;{pos}H\033[K")
    out.write(message)
    out.flush()

    return True


def _dog_impl(ctx: task_context):
    p = Protocol(ctx)
    err = p.negotiate()
    if err:
        print(err)
        return 1

    p.send(
        CYCLE(
            cycle_id = 0,
            scope = None,
            is_fresh = True,
            sources = {
                "BUILD.bazel": SOURCE_FILE(mtime = 0)
            }
        )
    )

    print(p.recv())
    print(p.recv())


    p.send(
        CYCLE(
            cycle_id = 0,
            scope = None,
            is_fresh = True,
            sources = {
                "BUILD.bazel": SOURCE_FILE(mtime = 0)
            }
        )
    )

    print(p.recv())
    print(p.recv())

    # watchdog(ctx, watch_loop)


watch = task(
    implementation = _dog_impl,
    args = {
        "target": args.positional()
    },
)
