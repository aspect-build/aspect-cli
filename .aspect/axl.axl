"""
Exercise axl
"""
load("@demo//answer.axl", "ANSWER")
load("./lambda.axl", "lambda_with_global_bind")

def test_case(tc, cond, msg) -> int:
    if not cond:
        fail(msg)
    else:
        print(msg, "... OK")
    return tc + 1

def test_env(ctx: TaskContext, tc: int, temp_dir: str) -> int:
    # Test current_exe
    current_exe = ctx.std.env.current_exe()
    tc = test_case(tc, current_exe != None and current_exe != "", "current_exe should return a non-empty value")
    tc = test_case(tc, type(current_exe) == "string", "current_exe should be a string")
    tc = test_case(tc, current_exe.endswith("/aspect-cli"), "current_exe should end with /aspect-cli")

    # Test home_dir
    home = ctx.std.env.home_dir()
    tc = test_case(tc, home != None and home != "", "home_dir should return a non-empty value")
    tc = test_case(tc, type(home) == "string", "home_dir should be a string")

    # Test current_dir
    current_dir = ctx.std.env.current_dir()
    tc = test_case(tc, current_dir != None and current_dir != "", "current_dir should return a non-empty value")
    tc = test_case(tc, type(current_dir) == "string", "current_dir should be a string")
    tc = test_case(tc, ctx.std.fs.is_dir(current_dir), "current_dir should be a directory")

    # Test var for existing and non-existing variables
    path_var = ctx.std.env.var("PATH")
    tc = test_case(tc, path_var != None and path_var != "", "PATH environment variable should exist and by non-empty")
    tc = test_case(tc, type(path_var) == "string", "PATH should be a string")
    no_var = ctx.std.env.var("NO_SUCH_VAR_12345")
    tc = test_case(tc, no_var == None, "Non-existent variable should return None")

    # Test vars
    all_vars = ctx.std.env.vars()
    tc = test_case(tc, type(all_vars) == "list", "vars should return a list")
    tc = test_case(tc, len(all_vars) > 0, "vars should contain at least one entry")
    # Check that vars entries are tuple of two strings
    for var in all_vars:
        tc = test_case(tc, type(var) == "tuple" and len(var) == 2, "Each var entry should be a tuple of length 2")
        tc = test_case(tc, type(var[0]) == "string" and type(var[1]) == "string", "Var entries should be string pairs")
        break

    # Test root_dir
    root_dir = ctx.std.env.root_dir()
    tc = test_case(tc, root_dir != None and root_dir != "", "root_dir should return a non-empty value")
    tc = test_case(tc, type(root_dir) == "string", "root_dir should be a string")
    tc = test_case(tc, ctx.std.fs.is_dir(root_dir), "root_dir should be a directory")

    return tc

def test_fs(ctx: TaskContext, tc: int, temp_dir: str):
    # Test ctx.std.fs API in a temporary test directory

    # Set up test directory in temp_dir
    test_dir = temp_dir + "/axl_fs_test"
    if ctx.std.fs.exists(test_dir):
        ctx.std.fs.remove_dir_all(test_dir)
    ctx.std.fs.create_dir(test_dir)
    tc = test_case(tc, ctx.std.fs.exists(test_dir), "create_dir should create the directory")
    tc = test_case(tc, ctx.std.fs.is_dir(test_dir), "created path should be a directory")
    tc = test_case(tc, not ctx.std.fs.is_file(test_dir), "created path should not be a file")

    # Test create_dir_all
    deep_dir = test_dir + "/deep/a/b"
    ctx.std.fs.create_dir_all(deep_dir)
    tc = test_case(tc, ctx.std.fs.exists(deep_dir), "create_dir_all should create nested directories")
    tc = test_case(tc, ctx.std.fs.is_dir(deep_dir), "nested path should be a directory")

    # Test write and read_to_string
    file_path = test_dir + "/test_file.txt"
    ctx.std.fs.write(file_path, "hello world")
    tc = test_case(tc, ctx.std.fs.exists(file_path), "write should create the file")
    tc = test_case(tc, ctx.std.fs.is_file(file_path), "written path should be a file")
    tc = test_case(tc, not ctx.std.fs.is_dir(file_path), "written path should not be a directory")
    content = ctx.std.fs.read_to_string(file_path)
    tc = test_case(tc, content == "hello world", "read_to_string should return the written content")

    # Test metadata and symlink_metadata
    meta = ctx.std.fs.metadata(file_path)
    at_least_epoch = 1763025368000000
    tc = test_case(tc, meta.is_file == True, "metadata.is_file should be True")
    tc = test_case(tc, meta.is_dir == False, "metadata.is_dir should be False")
    tc = test_case(tc, meta.is_symlink == False, "metadata.is_symlink should be False")
    tc = test_case(tc, meta.size == 11, "metadata.size should match content length")
    tc = test_case(tc, type(meta.modified) == "int" and meta.modified > at_least_epoch, "metadata.modified should be int and greater than at_least_epoch")
    tc = test_case(tc, type(meta.accessed) == "int" and meta.accessed > at_least_epoch, "metadata.accessed should be int and greater than at_least_epoch")
    tc = test_case(tc, (type(meta.created) == "NoneType" and meta.created == None) or (type(meta.created) == "int" and meta.created > at_least_epoch), "meta.created should be either None when creation time is not available on this platform currently or int and greater than at_least_epoch")
    tc = test_case(tc, type(meta.readonly) == "bool" and meta.readonly == False, "metadata.readonly should be bool and False")

    sym_meta = ctx.std.fs.symlink_metadata(file_path)
    tc = test_case(tc, sym_meta.is_file == True, "symlink_metadata.is_file should be True")
    tc = test_case(tc, sym_meta.is_dir == False, "symlink_metadata.is_dir should be False")
    tc = test_case(tc, sym_meta.is_symlink == False, "symlink_metadata.is_symlink should be False") # TODO: once we can create symlinks then update this test case
    tc = test_case(tc, sym_meta.size == 11, "metadata.size should match content length")
    tc = test_case(tc, type(sym_meta.modified) == "int" and sym_meta.modified > at_least_epoch, "symlink_metadata.modified should be int and greater than at_least_epoch")
    tc = test_case(tc, type(sym_meta.accessed) == "int" and sym_meta.accessed > at_least_epoch, "symlink_metadata.accessed should be int and greater than at_least_epoch")
    tc = test_case(tc, (type(sym_meta.created) == "NoneType" and sym_meta.created == None) or (type(sym_meta.created) == "int" and sym_meta.created > at_least_epoch), "symlink_metadata.created should be either None when creation time is not available on this platform currently or int and greater than at_least_epoch")
    tc = test_case(tc, type(sym_meta.readonly) == "bool" and sym_meta.readonly == False, "symlink_metadata.readonly should be bool and False")

    # Test copy
    copy_path = test_dir + "/copy.txt"
    ctx.std.fs.copy(file_path, copy_path)
    tc = test_case(tc, ctx.std.fs.exists(copy_path), "copy should create the new file")
    tc = test_case(tc, ctx.std.fs.read_to_string(copy_path) == "hello world", "copy should preserve content")

    # Test rename
    rename_path = test_dir + "/renamed.txt"
    ctx.std.fs.rename(copy_path, rename_path)
    tc = test_case(tc, not ctx.std.fs.exists(copy_path), "rename should remove old path")
    tc = test_case(tc, ctx.std.fs.exists(rename_path), "rename should create new path")
    tc = test_case(tc, ctx.std.fs.read_to_string(rename_path) == "hello world", "rename should preserve content")

    # Test hard_link
    hard_path = test_dir + "/hard_link.txt"
    ctx.std.fs.hard_link(file_path, hard_path)
    tc = test_case(tc, ctx.std.fs.exists(hard_path), "hard_link should create the link")
    tc = test_case(tc, ctx.std.fs.read_to_string(hard_path) == "hello world", "hard_link should share content")
    # Modify original and check link
    ctx.std.fs.write(file_path, "updated")
    tc = test_case(tc, ctx.std.fs.read_to_string(hard_path) == "updated", "hard_link should reflect changes")

    # Test read_dir
    entries = ctx.std.fs.read_dir(test_dir)
    tc = test_case(tc, type(entries) == "list", "read_dir should return a list")
    tc = test_case(tc, len(entries) > 0, "read_dir should find entries")
    # Check for specific entries (basenames)
    found_file = False
    found_deep = False
    for entry in entries:
        tc = test_case(tc, type(entry.path) == "string", "DirEntry.path should be string")
        tc = test_case(tc, type(entry.is_file) == "bool", "DirEntry.is_file should be bool")
        tc = test_case(tc, type(entry.is_dir) == "bool", "DirEntry.is_dir should be bool")
        if entry.path == "test_file.txt":
            tc = test_case(tc, entry.is_file == True, "file entry should be file")
            tc = test_case(tc, entry.is_dir == False, "file entry should not be dir")
            found_file = True
        if entry.path == "deep":
            tc = test_case(tc, entry.is_dir == True, "deep entry should be dir")
            tc = test_case(tc, entry.is_file == False, "deep entry should not be file")
            found_deep = True
    tc = test_case(tc, found_file, "read_dir should find test_file.txt")
    tc = test_case(tc, found_deep, "read_dir should find deep")

    # Test remove_file
    ctx.std.fs.remove_file(rename_path)
    tc = test_case(tc, not ctx.std.fs.exists(rename_path), "remove_file should delete the file")

    # Test remove_dir_all
    ctx.std.fs.remove_dir_all(test_dir)
    tc = test_case(tc, not ctx.std.fs.exists(test_dir), "remove_dir_all should delete recursively")

    # Test remove_dir on empty directory
    empty_dir = temp_dir + "/axl_empty_test"
    ctx.std.fs.create_dir(empty_dir)
    tc = test_case(tc, ctx.std.fs.exists(empty_dir), "create_dir should work for empty test")
    ctx.std.fs.remove_dir(empty_dir)
    tc = test_case(tc, not ctx.std.fs.exists(empty_dir), "remove_dir should delete empty directory")

    # Note: Skipping remove_dir on non-empty as we can't test the fail case in this context
    # Note: Skipping read_link as there is no symlink creation API to test with
    return tc

def test_stream(ctx: TaskContext, tc: int, temp_dir: str) -> int:
    # Test Writable.close() on child stdin
    # Spawning cat with piped stdin/stdout, writing data, closing stdin (signals EOF),
    # then verifying the output and exit code

    # Test 1: Basic close on child stdin
    child = ctx.std.process.command("cat").stdin("piped").stdout("piped").spawn()
    stdin = child.stdin()
    stdout = child.stdout()

    stdin.write("Hello from AXL!\n")
    stdin.flush()
    stdin.close()

    output = stdout.read_to_string()
    status = child.wait()

    tc = test_case(tc, output == "Hello from AXL!\n", "close on stdin should signal EOF, cat should echo input")
    tc = test_case(tc, status.code == 0, "cat should exit with code 0 after stdin is closed")

    # Test 2: Multiple writes then close
    child2 = ctx.std.process.command("cat").stdin("piped").stdout("piped").spawn()
    stdin2 = child2.stdin()
    stdout2 = child2.stdout()

    stdin2.write("Line 1\n")
    stdin2.write("Line 2\n")
    stdin2.write("Line 3\n")
    stdin2.flush()
    stdin2.close()

    output2 = stdout2.read_to_string()
    status2 = child2.wait()

    tc = test_case(tc, output2 == "Line 1\nLine 2\nLine 3\n", "multiple writes before close should all be received")
    tc = test_case(tc, status2.code == 0, "cat should exit with code 0 after multiple writes and close")

    # Test 3: Close without any writes (empty input)
    child3 = ctx.std.process.command("cat").stdin("piped").stdout("piped").spawn()
    stdin3 = child3.stdin()
    stdout3 = child3.stdout()

    stdin3.close()

    output3 = stdout3.read_to_string()
    status3 = child3.wait()

    tc = test_case(tc, output3 == "", "close without writes should result in empty output")
    tc = test_case(tc, status3.code == 0, "cat should exit with code 0 after immediate close")

    return tc

def test_starlark(tc: int) -> int:
    tc = test_case(tc, lambda_with_global_bind()("testing") == "%testing%", "should be able to call a lambda bound to a global from another module")
    tc = test_case(tc, ANSWER == 42, "should be able to load the answer to Life the Universe and Everything from an axl module")
    return tc

def test_http(ctx: TaskContext, tc: int, temp_dir: str) -> int:
    # Test HTTP download with integrity/sha256 verification
    # Using a well-known static file: LICENSE from this repo's GitHub
    test_dir = temp_dir + "/axl_http_test"
    if ctx.std.fs.exists(test_dir):
        ctx.std.fs.remove_dir_all(test_dir)
    ctx.std.fs.create_dir(test_dir)

    # URL to a small, stable file (Apache 2.0 license text from GitHub)
    url = "https://raw.githubusercontent.com/aspect-build/aspect-cli/refs/heads/main/LICENSE"
    # SHA-256 of Apache 2.0 license file
    expected_sha256 = "0d542e0c8804e39aa7f37eb00da5a762149dc682d7829451287e11b938e94594"
    expected_integrity = "sha256-DVQuDIgE45qn836wDaWnYhSdxoLXgpRRKH4RuTjpRZQ="

    # Test 1: Download with correct sha256 (hex format like Bazel)
    output1 = test_dir + "/license_sha256.txt"
    resp1 = ctx.http().download(url = url, output = output1, mode = 0o644, sha256 = expected_sha256).block()
    tc = test_case(tc, resp1.status == 200, "download with sha256 should return status 200")
    tc = test_case(tc, ctx.std.fs.exists(output1), "download with sha256 should create the file")
    content1 = ctx.std.fs.read_to_string(output1)
    tc = test_case(tc, "Apache License" in content1, "downloaded file should contain Apache License text")

    # Test 2: Download with correct integrity (SRI format)
    output2 = test_dir + "/license_integrity.txt"
    resp2 = ctx.http().download(url = url, output = output2, mode = 0o644, integrity = expected_integrity).block()
    tc = test_case(tc, resp2.status == 200, "download with integrity should return status 200")
    tc = test_case(tc, ctx.std.fs.exists(output2), "download with integrity should create the file")
    content2 = ctx.std.fs.read_to_string(output2)
    tc = test_case(tc, content1 == content2, "both downloads should have identical content")

    # Test 3: Download without checksum (should succeed)
    output3 = test_dir + "/license_no_check.txt"
    resp3 = ctx.http().download(url = url, output = output3, mode = 0o644).block()
    tc = test_case(tc, resp3.status == 200, "download without checksum should return status 200")
    tc = test_case(tc, ctx.std.fs.exists(output3), "download without checksum should create the file")

    # Note: Cannot test checksum mismatch without try/catch in Starlark.
    # The checksum verification is tested implicitly - if hashes didn't match,
    # the tests above would have failed.

    # Cleanup
    ctx.std.fs.remove_dir_all(test_dir)

    return tc

def impl(ctx: TaskContext) -> int:
    tc = 0

    print("Aspect CLI", ctx.std.env.aspect_cli_version())
    if ctx.std.env.var("ASPECT_LAUNCHER"):
        print("aspect-launcher detected")
    else:
        print("aspect-launcher not detected")

    # Test aspect_cli_version (on CI only)
    if ctx.std.env.var("CI"):
        print("CI enviroment detected")
        tc = test_case(tc, ctx.std.env.aspect_cli_version() == "0.0.0-dev", "aspect-cli version should be 0.0.0-dev")
        tc = test_case(tc, ctx.std.env.var("ASPECT_LAUNCHER") == "true", "ASPECT_LAUNCHER should be true")
        tc = test_case(tc, ctx.std.env.var("ASPECT_LAUNCHER_VERSION") == "0.0.0-dev", "ASPECT_LAUNCHER_VERSION should be 0.0.0-dev")
        tc = test_case(tc, ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_METHOD") == "local", "ASPECT_LAUNCHER_ASPECT_CLI_METHOD should be local")
        tc = test_case(tc, ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_PATH") == "bazel-bin/crates/aspect-cli/aspect-cli", "ASPECT_LAUNCHER_ASPECT_CLI_PATH should be bazel-bin/crates/aspect-cli/aspect-cli")
        tc = test_case(tc, ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_URL") == None, "ASPECT_LAUNCHER_ASPECT_CLI_URL should be None")
        tc = test_case(tc, ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_ORG") == None, "ASPECT_LAUNCHER_ASPECT_CLI_ORG should be None")
        tc = test_case(tc, ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_REPO") == None, "ASPECT_LAUNCHER_ASPECT_CLI_REPO should be None")
        tc = test_case(tc, ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_RELEASE") == None, "ASPECT_LAUNCHER_ASPECT_CLI_RELEASE should be None")
        tc = test_case(tc, ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_ARTIFACT") == None, "ASPECT_LAUNCHER_ASPECT_CLI_ARTIFACT should be None")
    else:
        print("local enviroment detected")
        print("ASPECT_LAUNCHER_VERSION", ctx.std.env.var("ASPECT_LAUNCHER_VERSION"))
        print("ASPECT_LAUNCHER_ASPECT_CLI_METHOD", ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_METHOD"))
        print("ASPECT_LAUNCHER_ASPECT_CLI_PATH", ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_PATH"))
        print("ASPECT_LAUNCHER_ASPECT_CLI_URL", ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_URL"))
        print("ASPECT_LAUNCHER_ASPECT_CLI_ORG", ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_ORG"))
        print("ASPECT_LAUNCHER_ASPECT_CLI_REPO", ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_REPO"))
        print("ASPECT_LAUNCHER_ASPECT_CLI_RELEASE", ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_RELEASE"))
        print("ASPECT_LAUNCHER_ASPECT_CLI_ARTIFACT", ctx.std.env.var("ASPECT_LAUNCHER_ASPECT_CLI_ARTIFACT"))

    # Test temp_dir
    temp_dir = ctx.std.env.temp_dir()
    tc = test_case(tc, type(temp_dir) == "string", "temp_dir should be a string")
    tc = test_case(tc, ctx.std.fs.is_dir(temp_dir), "temp_dir should be a directory")

    tc = test_env(ctx, tc, temp_dir)
    tc = test_fs(ctx, tc, temp_dir)
    tc = test_stream(ctx, tc, temp_dir)
    tc = test_starlark(tc)
    tc = test_http(ctx, tc, temp_dir)

    print(tc, "tests passed")
    return 0

axl = task(
    group = ["tests"],
    implementation = impl,
    args = {}
)
